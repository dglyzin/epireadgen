import Control.Monad.State
import Control.Monad.Writer
import System.Random
import Data.Ratio
import Data.List
import Data.Foldable
import System.IO
import Data.Time.Clock.System


-- the jumping to one unit either right or left
jump::(RandomGen g)=>State g Int 
jump = state (\g->
                   let (a, g') = (randomR (0, 1)) g in
                     if a>0 then (a, g') else (-1, g'))

type SuccX g = StateT Int (State g)

-- extending the jump transformer with an int context: 
succ_x::(RandomGen g)=> (SuccX g Int)
succ_x = do
  modify (\i->i+1)
  
  -- gen will be updated automaticaly:
  r<-lift $ jump
  return r

-- define a sum of jumping steps by wrapping in yet another StateT context:
type SumStates = [Int]
type SuccSum g = StateT SumStates (SuccX g)
succ_sum::(RandomGen g)=>SuccSum g Int
succ_sum = do
  
  -- gen will be updated automaticaly:
  x<-lift $ succ_x
  
  -- modify the state:
  sn <- get
  let prev = (case sn of
                [] -> 0
                (_:_) -> (head sn))
  let sn' = prev+x
  put ([sn']++sn)
  
  return sn'

-- and another context for some sums process events:
type EventStates = [String]
type EventHandler g = StateT EventStates (SuccSum g)
succ_ehandler::(RandomGen g)=> EventHandler g Int
succ_ehandler = do
  sn<-lift $ succ_sum
  
  -- after previous line this will be ready
  -- (i.e. the lifted state will be changed):
  i<-lift $ lift $ get

  -- catching some events:
  case sn of 0 ->               
               modify (\s->s++["zero sn in step "++(show i)])
             _ ->
               -- this just means do nothing
               return ()

  --modify (\s-> s++["ho"])             

  -- catching some more events:
  snl<- lift $ get
  case snl of (sn':sn'':_) ->
                if sn' >= sn'' then
                  modify (\s->s++["going up:"++(show sn')++" from "++ (show sn'')])
                else
                  modify (\s->s++["going down:"++(show sn')++" from "++(show sn'')])
              snl' ->
                return ()
  return sn

-- helper:
type SeqState g = ((((Int, EventStates), SumStates), Int), g)
run_once::(RandomGen g)=>EventHandler g Int->EventStates->SumStates->Int->g->SeqState g
run_once ehandler est sumst jst gen = (runState (runStateT (runStateT (runStateT ehandler est) sumst) jst) gen)

-- helper:
succ_seq::(RandomGen g)=>EventHandler g Int->StateT Int (EventHandler g) ()
succ_seq succ = do
  a<-lift $ succ
  return ()

-- and, finally, the sotch. process, generated by StateT transformer:
type SeqState' g = StateT Int (EventHandler g)
--succ_seq = state (\((((a, est), sumst), jst), gen)->run_once succ_ehandler est sumst jst gen)

succ_seq1::(RandomGen g)=> [Int] -> SeqState' g ()
succ_seq1 = traverse_ (\j-> succ_seq succ_ehandler)
-- TODO: collect weights

main = do
  time <- getSystemTime
  let gen = (mkStdGen (read (show (systemNanoseconds time))))
  (putStr "test3: succ_seq1::\n")
  (putStr $ (show (runState (runStateT (runStateT (runStateT (runStateT (succ_seq1 [1..7]) 0) []) []) 0) gen)))
  --(putStr $ (show (run_once (runStateT (succ_seq1 [1..7]) 0) [] [] 0 gen)))
  (putStr "\n----------------\n")

  (putStr "test2: succ_ehandler:\n")
  (putStr $ (show (run_once succ_ehandler [] [] 0 gen)))
  (putStr "\n----------------\n")

  (putStr "test1: succ_sum:\n")
  (putStr $ (show (runState (runStateT (runStateT succ_sum []) 0) gen)))
  (putStr "\n----------------\n")

  (putStr "test0: succ_x:\n")
  (putStr $ (show (runState (runStateT (succ_x) 0) gen)))
  (putStr "\n----------------\n")
