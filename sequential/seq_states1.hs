import Control.Monad.State
import Control.Monad.Writer
import System.Random
import Data.Ratio
import Data.List
import Data.Foldable
import System.IO
import Data.Time.Clock.System


-- the jumping to one unit either right or left
jump::(RandomGen g)=>State g Int 
jump = state (\g->
                   let (a, g') = (randomR (0, 1)) g in
                     if a>0 then (a, g') else (-1, g'))

type SuccX g = StateT Int (State g)

-- extending the jump transformer with an int context: 
succ_x::(RandomGen g)=> (SuccX g Int)
succ_x = do
  modify (\i->i+1)
  
  -- gen will be updated automaticaly:
  r<-lift $ jump
  return r

-- define a sum of jumping steps by wrapping in yet another StateT context:
type SumStates = [Int]
type SuccSum g = StateT SumStates (SuccX g)
succ_sum::(RandomGen g)=>SuccSum g Int
succ_sum = do
  
  -- gen will be updated automaticaly:
  x<-lift $ succ_x
  
  -- modify the state:
  sn <- get
  let prev = (case sn of
                [] -> 0
                (_:_) -> (head sn))
  let sn' = prev+x
  put ([sn']++sn)
  
  return sn'

-- and another context for some sums process events:
type EventState = (String, String, String)
type EventStates = [[EventState]]
type EventHandler g = StateT EventStates (SuccSum g)
succ_ehandler::(RandomGen g)=> EventHandler g Int
succ_ehandler = do
  sn<-lift $ succ_sum
  
  -- after previous line this will be ready
  -- (i.e. the lifted state will be changed):
  i<-lift $ lift $ get

  let collected_events = (
        case sn of
          0 -> [("zero sn in step ", (show i), "")]
          _ -> [])
  -- catching some events:
  {-
  case sn of 0 ->
               --collected_events = collected_events ++ [("zero sn in step ", (show i), "")]
               -- return ()
               modify (\s->s++[("zero sn in step ", (show i), "")])
             _ ->
               -- this just means do nothing (not actual return from func)
               return ()
  -}
  --modify (\s-> s++["ho"])             

  -- catching some more events:
  snl<- lift $ get
  
  let collected_events1 = collected_events ++ (
        case snl of (sn':sn'':_)->
                      if sn' >= sn'' then
                        [("going up:", (show sn''), (show sn'))]
                      else
                        [("going down:", (show sn''), (show sn'))]
                    snl' -> [])
  modify (\s->s++[collected_events1])                     
  {-
  case snl of (sn':sn'':_) ->
                if sn' >= sn'' then
                  modify (\s->s++[("going up:", (show sn''), (show sn'))])
                else
                  modify (\s->s++[("going down:", (show sn''), (show sn'))])

              -- otherwise
              snl' ->
                return ()
  -}
  return sn

-- helper:
type SeqState g = ((((Int, EventStates), SumStates), Int), g)
run_once::(RandomGen g)=>EventHandler g Int->EventStates->SumStates->Int->g->SeqState g
run_once ehandler est sumst jst gen = (runState (runStateT (runStateT (runStateT ehandler est) sumst) jst) gen)

-- helper (for traverse_):
succ_seq::(RandomGen g)=>EventHandler g Int->StateT Int (EventHandler g) ()
succ_seq succ = do
  a<-lift $ succ
  return ()

-- and, finally, the sotch. process, generated by StateT transformer:
type SeqState' g = StateT Int (EventHandler g)
--succ_seq = state (\((((a, est), sumst), jst), gen)->run_once succ_ehandler est sumst jst gen)

succ_seq1::(RandomGen g)=> [Int] -> SeqState' g ()
succ_seq1 = traverse_ (\j-> succ_seq succ_ehandler)
-- TODO: collect weights

type WeightedStates = [(EventState, Int)]
type EventWeightedHandler g = StateT WeightedStates (EventHandler g)

-- collect counts of all happend events during sequential execution of succ_ehandler (i.e factorize them mod time): 
succ_ewhandler::(RandomGen g)=> EventWeightedHandler g ()
succ_ewhandler = do
  x <- lift $ succ_ehandler
  events <- lift $ get
 
  case events of (e:es)->
                   modify (\s-> update s (last events))
                 --(e:es)->modify (\s->s++[(((show e),(show x),(show events)),1)])
                 []-> return ()
                 
  return ()

-- events factorization - if more then one have happend then
-- (from, to) value will be ignored (replaced by ("", "")):
update::WeightedStates->[EventState]->WeightedStates
update xs@(((ex1, ex2, ex3), val):rxs) es@((e1,e2,e3):res)
  | ex1 == e1 = [((ex1, "", ""), val+1)] ++ (update rxs res) 
  | otherwise = [((ex1, "", ""), val)]++(update rxs es)  
    
update [] (e:res) = (update [(e, 1)] res)
update xs [] = xs
    
succ_seq1w::(RandomGen g)=>[Int]->EventWeightedHandler g ()
succ_seq1w = traverse_ (\j->succ_ewhandler)

main = do
  time <- getSystemTime
  let gen = (mkStdGen (read (show (systemNanoseconds time))))

  (putStr "test4: succ_seq1w::\n")
  (putStr $ (show (runState (runStateT (runStateT (runStateT (runStateT (succ_seq1w [1..7]) []) []) []) 0) gen)))

  (putStr "test4.2: succ_ewhandler::\n")
  (putStr $ (show (runState (runStateT (runStateT (runStateT (runStateT (succ_ewhandler) []) []) []) 0) gen)))
  
  (putStr "\ntest4.1: update::\n")
  (putStr $ (show (update [] [("a", "a", "a")])))
  (putStr "\ntest3: succ_seq1::\n")
  (putStr $ (show (runState (runStateT (runStateT (runStateT (runStateT (succ_seq1 [1..7]) 0) []) []) 0) gen)))
  --(putStr $ (show (run_once (runStateT (succ_seq1 [1..7]) 0) [] [] 0 gen)))
  (putStr "\n----------------\n")

  (putStr "test2: succ_ehandler:\n")
  (putStr $ (show (run_once succ_ehandler [] [] 0 gen)))
  (putStr "\n----------------\n")

  (putStr "test1: succ_sum:\n")
  (putStr $ (show (runState (runStateT (runStateT succ_sum []) 0) gen)))
  (putStr "\n----------------\n")

  (putStr "test0: succ_x:\n")
  (putStr $ (show (runState (runStateT (succ_x) 0) gen)))
  (putStr "\n----------------\n")
